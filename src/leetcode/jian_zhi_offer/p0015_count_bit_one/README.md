#### [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

 

**示例 1：**

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

**示例 2：**

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

**示例 3：**

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

 

**提示：**

-   输入必须是长度为 `32` 的 **二进制串** 。



## 题解

### 解法一：最优解

**时间复杂度：$O(m)$ ，m为1的个数**

**空间复杂度：$O(1)$​**

**算法步骤：**

1.  初始化统计结果变量count

2.  如果 $n != 0$ 统计结果+1

3.  $n \&= n - 1$ 消除最右边的一个1，继续遍历

    n &= n - 1可以消除最右边的1，原理大家自行探究，其具体表现为：

    例如：取n = 100100， 则 n - 1 = 100011

    则 n & n - 1 = 100000，最右边的1

4.  返回统计结果

```java
    public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            count++;
            n &= n - 1;
        }
        return count;
    }
```



### 解法二：普通解法（易于理解）

**时间复杂度：O($log_2n$)** 

**空间复杂度：$O(1)$**

**算法步骤：**

1.  初始化统计结果变量count
2.  从低位到高位遍历每一个二进制位，如果 $ n \& 1$ 运算比较为1，则统计结果+1
3.  右移一个比特位，继续遍历
4.  返回统计结果

```java
    public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            count += n & 1;
            n = n >>> 1;
        }
        return count;
    }
```

